package emp.model; 									//essentially defines the file as an EMP project package to be used there exclusively
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//THIS CommonDao EXECISES (D.R.Y.) PRINCIPALS CONTAINS RE-OCCURING DATA INHERENT IN ALLTHE DIFFERENT DAO'S 
//
//			THE MANADTORY STEPS IN SETTING UP THIS COMMON DAO THAT SATISFY THE REOCCURING DAO NECCESSITIES IN ALL DAOS ARE:
//
//			(1)INCLUDE NECCESSARY DATABASE IMPORTS TO :
//				(a) get the   java.sql.Connection..........TO.....connect to a specific database					    ??????????????????????????????
//				(b) get the   java.sql.DriverManager.......TO.....associate eccentric Mysql/jdbc with this app	??????????????????????????????
//				(c) get the   java.sql.PreparedStatement...TO.....create an object that represents a precompiled SQL statement??????????????
//				(d) get the   java.sql.ResultSet...........TO.....create An exception that provides information on a database access error or other errors. ??????
//				(e) get the   java.sql.SQLException........TO.....create a object used for executing a static SQL statement and returning the results it produces?????????????
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///	NECCESSARY DATABASE IMPORTS////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//java.sql.Connection
//								connection (session) with a specific database. SQL statements are executed and 
//								results are returned within the context of a connection. 
//								A Connection object's database is able to provide information describing its tables, 
//								its supported SQL grammar, 
//								its stored procedures, the capabilities of this connection, and so on. 
//								This information is obtained with the getMetaData method. 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.sql.Connection;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//java.sql.DriverManager
//
//								The basic service for managing a set of JDBC drivers.
//								The use of a DataSource object is the preferred means of connecting to a data source. 
//								As part of its initialization, the DriverManager class will attempt to load the driver classes 
//								referenced in the "jdbc.drivers"system property.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.sql.DriverManager;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//java.sql.PreparedStatement
//
//								An object that represents a precompiled SQL statement. 
//								A SQL statement is precompiled and stored in a PreparedStatement object.
//								This object can then be used to efficiently execute this statement multiple times. 
//								Note: The setter methods (setShort, setString,and so on) for setting IN parameter values must specify 
//								types that are compatible with the defined SQL type of the input parameter. 
//								For instance, if the IN parameter has SQL type INTEGER, then the method setInt should be used.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.sql.PreparedStatement;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//java.sql.ResultSet
//
//								A table of data representing a database result set, which is usually generated by 
//								executing a statement that queries the database. 
//								A ResultSet object maintains a cursor pointing to its current row of data. 
//								Initially the cursor is positioned before the first row. 
//								The next method moves the cursor to the next row, and because it returns false when there are 
//								no more rows in the ResultSet object,it can be used in a while loop to iterate through the result set. 
//								A default ResultSet object is not updatable and has a cursor that moves forward only. 
//								Thus, you can iterate through it only once and only from the first row to the last row. It is possible to
//								produce ResultSet objects that are scrollable and/or updatable. The following code fragment, in which con is 
//								a valid Connection object, illustrates how to make a result set that is scrollable and insensitive to updates by others, 
//									and that is updatable. See ResultSet fields for other options. 
//
//  							Statement stmt = con.createStatement(
//             						 ResultSet.TYPE_SCROLL_INSENSITIVE,
//             						 ResultSet.CONCUR_UPDATABLE);
//       							 ResultSet rs = stmt.executeQuery("SELECT a, b FROM TABLE2");
//       							// rs will be scrollable, will not show changes made by others,
//       							// and will be updatable
//
//									The ResultSet interface provides getter methods (getBoolean, getLong, and so on)
//									for retrieving column values from the current row.
//									Values can be retrieved using either the index number of the column or the name of the column. 
//			    					In general, using the column index will be more efficient. Columns are numbered from 1.
//									For maximum portability, 
//									result set columns within each row should beread in left-to-right order, and each column should be read only once. 
//									For the getter methods, a JDBC driver attempts to convert the underlying data to the Java type specified in the 
//									getter method and returns a suitable Java value. The JDBC specification has a table showing the allowable mappings 
//									from SQL types to Java types that can be used by the ResultSet getter methods. 
//
//									Column names used as input to getter methods are case insensitive. 
//									When a getter method is called with a column name and several 
//									columns have the same name,the value of the first matching column will be returned.
//									The column name option is designed to be 
//									used when column names are used in the SQLquery that generated the result set.
//									For columns that are NOT explicitly named in the query, 
//									it is best to use column numbers. If column names are used, the programmer 
//									should take care to guarantee that they uniquely refer to the 
//									intended columns, which can be assured with the SQL AS clause. 
//
//									A set of updater methods were added to this interface in the JDBC 2.0 API (Java™ 2 SDK,Standard Edition, version 1.2). 
//									The comments regarding parameters to the getter methods also apply to parameters to the updater methods. 
//
//										The updater methods may be used in two ways: 
//
//									1.to update a column value in the current row. 
//									In a scrollable ResultSet object, the cursor can be moved 
//									backwards and forwards, to an absolute position, or to a position relative to the current row.
//									The following code fragment updates the NAME 
//									column in the fifth row of the ResultSet object rs and then uses the method updateRowto 
//									update the data source table from which rs was derived. 
//
//       							rs.absolute(5); 						// moves the cursor to the fifth row of rs
//       							rs.updateString("NAME", "AINSWORTH"); 	// updates the
//          												// NAME column of row 5 to be AINSWORTH
//       							rs.updateRow(); 						// updates the row in the data source
//
// 
//
//									2.to insert column values into the insert row. 
//									An updatable ResultSet object has a special row associated with it that serves 
//									as a staging area for building a row to be inserted.The following code fragment 
//										moves the cursor to the insert row, builds
//									a three-column row, and inserts it into rs and into the data source table using the method insertRow. 
//
//       		    				rs.moveToInsertRow(); 					// moves cursor to the insert row
//       							rs.updateString(1, "AINSWORTH"); 		// updates the
//          												// first column of the insert row to be AINSWORTH
//       							rs.updateInt(2,35); // updates the second column to be 35
//       							rs.updateBoolean(3, true); // updates the third column to true
//       							rs.insertRow();
//       							rs.moveToCurrentRow();
//
//
//									A ResultSet object is automatically closed when the Statement object that generated it is closed, 
//									re-executed, or used to retrieve the next result from a sequence of multiple results. 
//
//									The number, types and properties of a ResultSet object's columns are 
//									provided by the ResultSet MetaData object returned by the ResultSet.getMetaData method.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.sql.ResultSet;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//java.sql.SQLException
//								An exception that provides information on a database access error or other errors. 
//
//								Each SQLException provides several kinds of information: 
//								• a string describing the error. This is used as the Java Exception message, available via the method getMesasge. 
// 							    • a "SQLstate" string, which follows either the XOPEN SQLstate conventions or the SQL:2003 conventions.The values 
//									of the SQLState string are described in the appropriate spec.The DatabaseMetaData method getSQLStateTypecan be 
//									used to discover whether the driver returns the XOPEN type or the SQL:2003 type. 
//								• an integer error code that is specific to each vendor. Normally this will be the actual error code 
//									reurned by the underlying database. 
//								• a chain to a next Exception. This can be used to provide additional error information. 
//								• the causal relationship, if any for this SQLException. 
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.sql.SQLException;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//java.sql.Statement
//								The object used for executing a static SQL statement and returning the results it produces. 
//
//								By default, only one ResultSet object per Statement object can be open at the same time. Therefore, 
//								if the reading of one ResultSet object is interleaved with the reading of another, each must have been 
//								generated by different Statement objects. All execution methods in the Statement interface implicitly close 
//								a current ResultSet object of the statement if an open one exists.
//							
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
import java.sql.Statement;


//////////////////////////////////BEGIN DAO CLASS/////////////////////////////////////////////////////////////////////////////
//
// PARRENT CLASS has.....(D.R.Y.  S T U F F)  
//							a.) defined (D.R.Y.)  reusable objects neccessary to accomplish the 4 
//								included manadatory dao function needs of 
//									1) Create a usable connection return  object 
//									2) Create a usable Statement return  object
//									3) Create a usable preparedStatement  return  object
//									4) Create a usable ResutSet return  object
//
//  						b.) defined (D.R.Y.)  reusable objects neccessary to accomplish connection 
//				
//  						c.) defined (D.R.Y.)  reusable objects neccessary to accomplish get the table data 
// 			
//							d.) defined (D.R.Y.)  reusable objects neccessary to accomplish querying the database 
//								and place results in a reusable object
// 	
//
//
//
//
//
//	METHOD	:	.getConnection(String url, String user, String password) throws SQLException
//												Attempts to establish a connection to the given database URL.
//												The DriverManager attempts to select an appropriate driver from	the set of registered JDBC drivers. 
//
//	METHOD : createStatement() 
//												Creates a Statement object for sendingSQL statements to the database.SQL statements 
//												without parameters are normally executed using Statement objects. If the same SQL 
//												statement is executed many times, it may be more efficient to use a PreparedStatement object. 
//
//												Result sets created using the returned Statement object will by default be type 
//												TYPE_FORWARD_ONLYand have a concurrency level of CONCUR_READ_ONLY.The hold ability of 
//												the created result sets can be determined by calling getHoldability.
//												Returns:a new default Statement objectThrows:SQLException - if a database access error occurs 
//												or this method is called on a closed connection
//
//

//
//	METHOD : prepare(String sql)
//
//												java.sql.PreparedStatementAn object that represents a precompiled SQL statement. 
//
//												A SQL statement is precompiled and stored in a PreparedStatement object. 
//												This object can then be used toefficiently execute this statement multiple times. 
//
//												Note: The setter methods (setShort, setString,and so on) for setting IN parameter valuesmust 
//												specify types that are compatible with the defined SQL type ofthe input parameter. 
//												For instance, if the IN parameter has SQL type INTEGER, then the method setInt should be used. 
//
//
//	METHOD : .prepareStatement(String sql) throws SQLException  from  PreparedStatement java.sql.Connection
//												Creates a PreparedStatement object for sending parameterized SQL statements to the database. 
//
//												A SQL statement with or without IN parameters can be pre-compiled and stored in a PreparedStatement object. 
//												This object can then be used to efficiently execute this statement multiple times. 
//
//
//	METHOD :  forName(String className) throws ClassNotFoundException
//												Returns the Class object associated with the class or interface with the given string name. Invoking this method isequivalent to: 
//
//												Class.forName(className, true, currentLoader) 
//												where currentLoader denotes the defining class loader ofthe current class. 
//												For example, the following code fragment returns the runtime Class descriptor for the class named java.lang.Thread: 
//
//												Class t = Class.forName("java.lang.Thread") 
//
//												A call to forName("X") causes the class named X to be initialized.
//												Parameters:className the fully qualified name of the desired class.Returns:the Class object for the class with the specified name.
//											
//
//
//	METHOD : getRecord(String tableName, String columnName, String columnValue)
//			
//         										(1) binds the results of an individual prepared SQL statement to the connection object instance "conn" 
//									  					and assigned that over to another alius instance ptsmt
///												(2) ????????maybe gets (via  a..... parseint()) and sets (via  b.... setInt())the uid to an integer????????????????
//
//													a...int java.lang.Integer.parseInt(String s) throws NumberFormatException
//														Parses the string argument as a signed decimal integer. 
//														The characters in the string must all be decimal digits, except that the first character may be an 
//														ASCII minus sign '-'('\u005Cu002D') to indicate a negative value or anASCII plus sign '+' 
//														('\u005Cu002B') to indicate a positive value.
//
//													b...void java.sql.PreparedStatement.setInt(int parameterIndex, int x) throws SQLException
//														Sets the designated parameter to the given Java int value.
//														The driver converts this to an SQL INTEGER value when it sends it to the database.
//														Parameters:parameterIndex the first parameter is 1, the second is 2, ...x the parameter value
//		
//												(3) return result of type ResultSet;
//
//
//	METHOD : close() throws SQLException
//
//												Releases this Statement object's data base and JDBC resources immediately instead of waiting 
//												for this to happen when it is automatically closed.
//												It is generally good practice to release resources as soon as you are finished with them to avoid tying up database resources. 
//												Calling the method close on a Statement object that is already closed has no effect. 
//												Note:When a Statement object is closed, its current ResultSet object, if one exists, is also closed.
//
//
//
//
//
//
//--R I G H T   S I D E  C O D E   B L O C K   T R A C E   E X E C U T I O N -------------------------------------------------//		
//  
//	CDao_)...   class CommonDAO { head def
//	CDao_A)...  	Member data:
//	CDao_B)...  	Method :			connect()		affixes url suffix for this rendered page and java string variable initialized
//	CDao_C)... 	 	Method :			getTableData ( 
//	CDao_D)... 	 	Method :			getResultFromQuery (
//	CDao_E)... 	 	Method :			prepare (Prepare a database statement with a passed sql string statement) 
//	CDao_F)...   	Method :			---->>------------->>------------>>------------------------------------------>>  CDao_?)... 
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public class CommonDAO {																										//  CDao_)...
		protected Connection conn 			= null; 																			// 	CDao_A)...  conn 		instance of type Connection 		type included above    null
		protected Statement stmt 			= null; 																			// 	CDao_A)...  stmt 		instance of type Statement 			type included above    null
		protected PreparedStatement pstmt 	= null; 																			// 	CDao_A)...  pstmt 		instance of type PreparedStatement 	type included above    null
		protected ResultSet result 			= null; 																			//	CDao_A)...  result 		instance of type ResultSet 			type included above    null		
																																//
																																//
		public void connect() throws Exception {																				//  CDao_B)...  connect()  {   	...LOADS MYSQL DATABASE DRIVER...CONNECTS TO DATABASE  throws 1
																																//	CDao_B)... 			class.forName...finds the class associated with the string arguments..in this case it is  MYSQL.JDBC          ????????????????????????????????????????????????????????????????????????????????????????
			Class.forName("com.mysql.jdbc.Driver"); 																			//  CDao_B)...  			Register JDBC Driver to this application        ??????????????????????????????????????????????
			conn = DriverManager.getConnection("jdbc:mysql://localhost/employees", "employees", "tset");  						//  CDao_B)... 			binds to passable connection instance "conn", passes table named employees, passes password  ??
		}																														//  CDao_B)... 	}
																																//																														// 	
		public ResultSet getTableData(String tableName, String orderBy) throws Exception {										//  CDao_C)...  getTableData( PASSES 2 STRING sql ARGUMENTS...tableName, orderBy) throws 1 {
			return getResultFromQuery("SELECT * FROM " + tableName + " ORDER BY " + orderBy);									//	CDao_C)...			returns the result of passd string sql arguments ("SELECT * FROM " + tableName + " ORDER BY " + orderBy) 					
																																//	CDao_C)...	     	....GETS THE TABLE DATA AND PLACES IT IN THE ResultSet OBJECT FORMAT TO BE RETURNED AS SUCH	
		}																														//  CDao_C)...  }									
																																//
		public ResultSet getResultFromQuery(String query) throws Exception {													//	CDao_D)...  getResultFromQuery( PASSES 1 STRING ARGUMENT THAT HAPPENS TO BE A SQL QUERRY) throws 1){
			stmt 						= conn.createStatement(); 																//	CDao_D)...  		stmt 	= binded to connection instance "conn" the returned value associated with java library function createStatement()
			result 						= stmt.executeQuery(query); 															//	CDao_D)... 			result 	= binded to connection instance "stmt" the returned value associated with java library function executeQuery(with passed arg : query)
			return result;																										//  CDao_D)...  		returns   result (which is of type resultSet)
		}																														//  CDao_D)...  }
																																//
		public PreparedStatement prepare(String sql) throws Exception {															//  CDao_D)...  prepare(Prepare a database statement with a passed sql string statement)  {
			pstmt = conn.prepareStatement(sql);																					//  CDao_D)... 			ptsmt = sends the sql statements that are wrapped up in the "conn" instance to the database 		
			return pstmt;																										//	CDao_D)...  		returns ptsmt ...a precompiled preparedStatement
		}																													 	//  CDao_D)...  }
																																//
		public ResultSet getRecord(String tableName, String columnName, String columnValue) throws Exception {					//  CDao_E)... 	getRecord()	{
			pstmt = conn.prepareStatement("SELECT * FROM " + tableName + " WHERE " + columnName + " = ?");   					// 	CDao_E)... 	 		(1)  FROM ABOVE
			pstmt.setInt(1, Integer.parseInt(columnValue));																		// 	CDao_E)... 	 		(2)  FROM ABOVE    a...., b.....
			result = pstmt.executeQuery();																						// 	CDao_E)... 	 		(3)  FROM ABOVE
			return result;																										//  CDao_E)... 	 }
		}																														//
																																//
		public void close() {																									// CDao_F)...  close all the exceptions thrown above test for whether object were in their original remaining Null values
			if (result != null) {																								// CDao_F)...  Close Result Set
				try {																											// CDao_F)...  
					result.close();																								// CDao_F)...  
				} catch (SQLException e) {																						// CDao_F)...  
					e.printStackTrace();																						// CDao_F)...  
				}																												// CDao_F)...  
			}																													// CDao_F)...  
																																// CDao_F)...  
																																// CDao_F)...  Close Statement
			if (stmt != null) {																									// CDao_F)...  
				try {																											// CDao_F)...  
					stmt.close();																								// CDao_F)...  
				} catch (SQLException e) {																						// CDao_F)...  
					e.printStackTrace();																						// CDao_F)...  
				}																												// CDao_F)...  
			}																													// CDao_F)...  	
																																// CDao_F)...  Close Prepared Statement
			if (pstmt != null) {																								// CDao_F)...  
				try {																											// CDao_F)...  
					pstmt.close();																								// CDao_F)...  
				} catch (SQLException e) {																						// CDao_F)...  
					e.printStackTrace();																						// CDao_F)...  
				}																												// CDao_F)...  
			}																													// CDao_F)...  
																																// CDao_F)...  
																																// CDao_F)...   Close Connection
			if (conn != null) {																									// CDao_F)...  
				try {																											// CDao_F)...  
					conn.close();																								// CDao_F)...  
				} catch (SQLException e) {																						// CDao_F)...  
					e.printStackTrace();																						// CDao_F)...  
				}																												// CDao_F)...  
			}																													// CDao_F)...  
		}																														// CDao_F)...  
																																// CDao_F)...  
}																																// CDao_F)...   close servlet
